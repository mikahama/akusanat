#!! This is the Eastern Mari disambiguation file. It chooses
#!! the correct morphological analyses in any given sentence context.

#!! The file first defines sentence delimiters and tags and sets.
#!! Thereafter come the rules, each rule is listed below.


# ================ #
#!!  !!!Sentence delimiters
# ================ #

DELIMITERS = "<.>" "<!>" "<?>" "<...>" "<¶>" sent ;
#!! The delimiters are: "<.>" "<!>" "<?>" "<...>" "<¶>" sent

LIST DELIMITERS = "<.>" "<!>" "<?>" "<...>" "<¶>" "<,>" "<;>" sent ; #SASHA ADDED 30-07-2017

#PARENTHESES = "<$(>" "<$)>" "<$[>" "<$]>" "<${>" "<$}>" "<$«>" "<$»>" ;

# ============= #
# !!!Tags and sets
# ============= #

#!! The __Tags__ section lists all the tags inherited from the fst, and defines them for
#!! use in the syntactic analysis.
#!! The tags are documented in the root.lexc file, and here only listed for reference.

#!! The next section, __Sets__, contains sets defined
#!! on the basis of the tags listed here, those set names are not visible in the output.

LIST DAT-V = "куанаш" ;

LIST DAT-PO = "верч" "кӧра" ;

LIST DAT-A = "поян" "тале" "пайдале" ;

SETS

#!! !!Tags



#!! !Beginning and end of sentence

LIST BOS = (>>>) (<s>); #!! BOS
LIST EOS = (<<<) (</s>); #!! EOS

#!! !Clause boundary
LIST C-BOUNDARY = CS Rel ; #ADDED BY JEREMY AND SASHA 28-06-2017

# We define end of clause and beginning of clause in a way so that the file
# may be read both by the CG-2 and the vislcg formalisms.

#!! !Parts of speech tags

LIST N = N ;                    #!! N
LIST V = V ;                    #!! V
LIST A = A ;                    #!! A
LIST Adv = Adv ; 				#!! Adv
LIST CC = CC ; 					#!! CC
LIST CS = CS ; 					#!! CS
LIST Interj = Interj interj ij; #!! Interj
LIST Pron = Pron ; 				#!! Pron
LIST Num = Num ; 				#!! Num
LIST Pcle = Pcle ; 				#!! Pcle
LIST Clt = Clt ; 				#!! Clt
LIST Po = Po ; 					#!! Po

#!! WORD is the set of all POS
LIST WORD = N V A Adv CC CS Interj Pron Num Pcle Clt Po ;

#!! !Verbal tense and mood tags
LIST Prs = Prs ; 		 #!! Prs
LIST Prt1 = Prt1 ; 		 #!! Prt1
LIST Prt2 = Prt2 ; 		 #!! Prt2
LIST Fut = Fut ; 		 #!! Fut
LIST Imprt = Imprt ; 		 #!! Imprt
LIST Ind = Ind ind ; 		 #!! Ind
LIST Cond = Cond cond ; 	 #!! Cond
LIST Des = Des des ;		 #!! Des

#!! !Other verbal tags
LIST Act = Act ; 			 #!! Act
LIST ConNeg = ConNeg conneg; #!! ConNeg
LIST FutPrc = FutPrc ; 			 #!! FutPrc
LIST Ger = Ger ger ;		 #!! Ger
LIST Inf = Inf ; 			 #!! Inf
LIST Nec = Nec nec ;         #!! Nec
LIST Neg = Neg neg ; 		 #!! Neg
LIST NegPrc = NegPrc ; 			 #!! NegPrc
LIST Pass = Pass ; 			 #!! Pass
LIST Prc = Prc ; 			 #!! Prc
LIST PrfPrc = PrfPrc ; 			 #!! PrfPrc

#!! Verbal person-number tags
LIST Sg1 = Sg1 ; 			 #!! Sg1
LIST Sg2 = Sg2 ; 			 #!! Sg2
LIST Sg3 = Sg3 ; 			 #!! Sg3
LIST Pl1 = Pl1 ; 			 #!! Pl1
LIST Pl2 = Pl2 ; 			 #!! Pl2
LIST Pl3 = Pl3 ; 			 #!! Pl3


#!! !Numeral tags

LIST Sg = Sg sg ; 	  #!! Sg
LIST Pl = Pl pl ; 	  #!! Pl

#!! !Case tags

LIST Nom = Nom nom ;  #!! Nom
LIST Gen = Gen gen ;  #!! Gen
LIST Abl = Abl abl ;  #!! Abl
LIST Dat = Dat dat ;  #!! Dat
LIST Com = Com com ;  #!! Com
LIST Cns = Cns cns ;  #!! Cns
LIST Acc = Acc acc ;   #!! Acc
LIST Ins = Ins ins ;   #!! Ins
LIST Ine = Ine ine ;   #!! Ine
LIST Ill = Ill ill ;   #!! Ill
LIST Cmpr = Cmpr ; 	   #!! Cmpr (case)

#!! !Other nominal tags

LIST Pers = Pers ;	   #!! Pers
LIST Refl = Refl ; 	   #!! Refl
LIST Rel = Rel ; 	   #!! Rel
LIST Interr = Interr ; #!! Interr
LIST Recipr = Recipr ; #!! Recipr
LIST Dem = Dem ;	#!! Dem
LIST ABBR = ABBR ;	  #!! ABBR
LIST Pron1Sg = "мый" "Мый" ; #SASHA ADDED 3-07-2017
LIST Pron2Sg = "тый" "Тый" ; #SASHA ADDED 3-07-2017

#!! !Adjective comparison tags

LIST Pos = Pos ; 	 #!! Pos (?)
LIST Superl = Superl ; #!! Superl
LIST Comp = Comp ; 	   #!! Comp

#!! !Possessive suffix tags

LIST PxSg1 = PxSg1 ; #!! PxSg1
LIST PxSg2 = PxSg2 ; #!! PxSg2
LIST PxSg3 = PxSg3 ; #!! PxSg3
LIST PxPl1 = PxPl1 ; #!! PxPl1
LIST PxPl2 = PxPl2 ; #!! PxPl2
LIST PxPl3 = PxPl3 ; #!! PxPl3

#!! !Numeral tags

LIST Card = Card ; #!! Card
LIST Coll = Coll ;  #!! Coll
LIST Ord = Ord ;  #!! Ord
LIST Temp = Temp ;  #!! Temp (?)

#!! !Punctuation marks

LIST CLB = CLB ; 	  #!! CLB
LIST PUNCT = PUNCT ;  #!! PUCT
LIST LEFT = LEFT ; 	  #!! LEFT
LIST RIGHT = RIGHT ;  #!! RIGHT
LIST COMMA = "," ;	  #!! COMMA

#!! !Derivation tags
LIST Der/MWN = Der/MWN ; #!! Der/MWN
LIST Der/са = Der/са ;	 #!! Der/sa

#!! !Particles
LIST Qst = Qst ; #!! Qst
LIST Foc = Foc ; #!! Foc


#!! !Tags for internal testing
LIST CmpTest = CmpTest ; #!! CmpTest
LIST Err = Err ; #!! Err

LIST @ADVL> = @ADVL> ;
LIST @>P = @>P ;
LIST @>N = @>N ;
LIST @OBJ> = @OBJ> ;
LIST @SUBJ> = SUBJ> ;
LIST @+FMAINV = @+FMAINV ;
#!! !!Sets

LIST CASE = Nom Gen Abl Dat Com Cns Acc Ins Ine Ill Cmpr ; #!! * __CASE__ = all cases
SET OBLCASE = CASE - Nom ; #!! * __OBLCASE__ = All cases except Nom
SET VFIN = Ind | Cond | Des | Imprt ; #!! * __VFIN__ = All moods

LIST WORD = N V A Adv CC CS Interj Pron Num Pcle Clt Po ;

SET PRE-N = A OR Gen OR Num OR Dem ;

SET NON-PRE-N = WORD - PRE-N ;

SET ADJ-OR-NOUN = A | N ; #SASHA ADDED 30-06-2017

SET NOT-ADJ-OR-NOUN = WORD - ADJ-OR-NOUN ; #SASHA ADDED 2-07-2017

LIST DER-N = Der/MWN ; #JEREMY AND SASHA ADDED 28-06-2017
SET LEX-N = N - DER-N ; #JEREMY AND SASHA ADDED 28-06-2017

#!! !!!Rule section

SECTION

#!! !!Early, word-internal rules

#!! * __CmpTst__ remove CmpTst if not 1 N
REMOVE:CmpTst CmpTest IF (NOT 1 N);
#!! * __CmpTst2__ Select CmpTst in all other cases
SELECT:CmpTst2 CmpTest ; # Kill'em all


#!! !CC or Pcle
#!! * __teveteve1__ gives CC if two теве
SELECT:teveteve1 CC IF (0   ("теве"))(*1 ("теве"));
#!! * __teveteve1__ gives CC if two теве
SELECT:teveteve2 CC IF (*-1 ("теве"))(0  ("теве"));
#!! * __onlyteve__ gives Pcle if two теве
REMOVE:onlyteve  CC IF (0 ("теве"));

#!! * __PcleNotCC__ Lauseen alussa on Pcle
REMOVE:PcleNotCC CC IF (-1 BOS)(0 Pcle);

#!! * __Posna__ деч посна
SELECT:Posna Po IF (-1 ("деч"))(0 ("посна"));

#!! * __ikNum__ ик is never A
SELECT:ikNum Num IF (0 ("ик"));

#!! !Particles

#!! *__InterrQ__ if question mark anywhere to the right
SELECT:InterrQ Interr IF (0 Interr)(*1 ("?")) ; #SASHA ADDED 3-07-2017

#!! *__Interr__ removes Rel if question mark to the right somewhere
REMOVE:Interr Rel IF (0 Interr)(*1 ("?")); #SASHA MODIFIED 3-07-2017

#!! !Verbs

#!! * __Ind__ selects Ind if no Ind to the right or to the left

SELECT:Ind Ind IF (0 Ind)(*-1 DELIMITERS BARRIER Ind)(*1 DELIMITERS BARRIER Ind) ; #!! * __1SgAgr__ selects (Ind Sg1) if Pron1Sg to the right or to the left

#!! * __1SgAgr__ selects (Ind Sg1) if (Pron1Sg Nom) to the right or to the left
SELECT:1SgAgr (Ind Sg1) IF (0 Ind)(*-1 Pron1Sg + Nom BARRIER DELIMITERS)(*1 Pron1Sg + Nom BARRIER DELIMITERS) ; #SASHA ADDED 3-07-2017 

#!! * __2SgAgr__ selects (Ind Sg2) if Pron2Sg to the right or to the left
SELECT:2SgAgr (Ind Sg2) IF (0 Ind)(*-1 Pron2Sg + Nom BARRIER DELIMITERS)(*1 Pron2Sg + Nom BARRIER DELIMITERS) ; #SASHA ADDED 3-07-2017

#!! * __IndAfterInf__ selects Ind if Inf to the left
SELECT:IndAfterInf (Ind) IF (0 Ind)(-1 (Inf)) ; #SASHA ADDED 3-07-2017

#!! * __NotImpWhenInd__
REMOVE:NotImpWhenInd Imprt IF (*-1C Ind BARRIER COMMA); #JEREMY AND SASHA MODIFIED 28-06-2017

#!! * __NotImpWhenWords1__
REMOVE:NotImpWhenWords1 Imprt IF (-1 N)(0 N);

#!! * __NotImpWhenWords2__
REMOVE:NotImpWhenWords2 Imprt IF (-1 WORD LINK *-1 BOS BARRIER Imprt);

#!! Adjectives

SET LEX-A = A - (Der/MWN) ;

REMOVE:CompRak A + (".*рак"r) IF (0 Comp) ;

#!! *__RemAdjBeforeProp__ removes A if Prop to the left
REMOVE:RemAdjBeforeProp A IF (1 (Prop)) ; #SASHA ADDED 03-07-2017

#!! *__AdjBeforeMo__ selects A if Interr to the right
SELECT:AdjBeforeMo LEX-A IF (0 A)(1 Interr) ; #SASHA ADDED 3-07-2017

#!! * __AdjBeforeAN__ selects A if N or A to the right
SELECT:AdjBeforeAN LEX-A IF (0 A)(1 A OR N)(*1 N BARRIER NOT-ADJ-OR-NOUN) ; #SASHA MODIFIED 3-07-2017

#!! * __RemN__ removes N if N to the right
#REMOVE:RemN N IF (0 A)(1 N); #SASHA COMMENTED OUT 03-07-2017

##!! * __AdjAfterNbeforeEOS__ selects A if N to the left and EOS to the right (predicative position)
SELECT:AdjAfterNbeforeEOS LEX-A IF (0 A)(-1 N)(1 EOS) ; #SASHA ADDED 3-07-2017  

#!! *_AdjBeforeConjAdj_ selects A if conjuction and A to the right ;
SELECT:AdjBeforeConjAdj LEX-A IF (0 LEX-A)(1 CC)(2 LEX-A); #SASHA ADDED 30-06-2017

#!! * __AdjNotAdv__ removes Adv if N to the right
#REMOVE:AdjNotAdv Adv IF (0 A)(1 A OR N); #SASHA COMMENTED OUT 3-07-2017

#!! * __AdjNotPron__ removes Pron Pers if N to the right
REMOVE:AdjNotPron (Pron Pers) IF (0 A)(1 N); #SASHA MODIFIED 3-07-2017

#!! *__AdjNotN__ removes N if Pron Pers anywhere to the left
REMOVE:AdjNotN N IF (0 A)(*-1 Pron + Pers BARRIER DELIMITERS) ; #SASHA ADDED 03-07-2017

#!! * __RemAdj1__ removes A if no N or A follows
REMOVE:RemAdj1 A IF (0 N)(1 NOT-ADJ-OR-NOUN); #SASHA ADDED 30-06-2017

#!! *__RemAdj2__ removes A if no N or Pron in a clause
REMOVE:RemAdj2 A IF (0 N)(*-1 DELIMITERS BARRIER N OR Pron)(*1 DELIMITERS BARRIER N OR Pron); #SASHA ADDED 3-07-2017

#!! !Nouns

#!! *__RemNomIfPronLeft__ removes Nom if Pron Nom anywhere to the left
REMOVE:RemNifPronLeft (Nom) IF (0 N)(*-1 Pron + Nom BARRIER DELIMITERS) ; #SASHA ADDED 03-07-2017

#!! *__RemNomIfPronRight__ removes Nom if Pron Nom anywhere to the right
REMOVE:RemNifPronRight (Nom) IF (0 N)(*1 Pron + Nom BARRIER DELIMITERS) ; #SASHA ADDED 03-07-2017

#!! *__NomBeforeConjNom__ selects N Nom if conjoined with N Nom
SELECT:NomBeforeConjNom (N Nom) IF (0 N)(1 CC)(2 (N Nom)) ; #SASHA ADDED 3-07-2017

#!! *__NafterDem__ selects N if Dem to the left (demonstratives tend to be sole modifiers) 
SELECT:NafterDem N IF (0 N)(-1 (Dem Nom)) ; #SASHA ADDED 3-07-2017

#!! *__NotANoun__
REMOVE:NotANoun N IF (-1 Adv)(0 V)(1 EOS OR COMMA);

#!! *__NafterAbeforeEOS__
SELECT:NafterAbeforeEOS N IF (0 N)(-1 A)(1 EOS); #SASHA ADDED 3-07-2017

#!! *__RemNafterAdv__ removes N if adverb to the left
REMOVE:RemNafterAdv N (0 N)(-1 Adv) ; #SASHA ADDED 3-07-2017

#!! !Derivations

#!! * __RemDerMWN1__ removes Der/MWN if N is an option
REMOVE:RemDerMWN1 (Der/MWN) IF (0 LEX-N) ; #JEREMY AND SASHA ADDED 28-06-2017

#!! * __RemDerMWN2__ removes Der/MWN if N to the right
REMOVE:RemDerMWN2 (Der/MWN) IF (1 N);

#!! * __Dersa__ if noun follows
REMOVE:Dersa Der/са IF (0 ("<(.*)са>"r) + A);

#!! * __SelDerMWN__ select Der/MWN if no noun follows
SELECT:SelDerMWN (Der/MWN) IF (0 LEX-A)(*1 EOS BARRIER N); #SASHA MODIFIED 2-07-2017

#!! !Cases

#!! * __RemNomNif12left__ removes Nom with N if there is a verb with 1st or 2nd agreement to the lef
REMOVE:RemNomNif12 Nom IF (0 N)(*-1 Ind + Sg1 OR Ind + Sg2 OR Ind + Pl1 OR Ind + Pl2 BARRIER DELIMITERS) ; #SASHA ADDED 03-07-2017

#!! * __RemNomNif12right__ removes Nom with N if there is a verb with 1st or 2nd agreement to the right
REMOVE:RemNomNif12 Nom IF (0 N)(*1 Ind + Sg1 OR Ind + Sg2 OR Ind + Pl1 OR Ind + Pl2 BARRIER DELIMITERS) ; #SASHA ADDED 03-07-2017


#!! * __AccNeedsVerb__ prefers Nom (TODO: does this make sense? SASHA: it does but there was a typo, -1* instead of 1* in the third clause of the condition)
REMOVE:AccNeedsVerb Acc IF (0C Nom OR Acc) (NOT -1* VFIN BARRIER BOS) (NOT 1* VFIN BARRIER EOS); #SASHA MODIFIED 03-07-2017

SELECT:NomCC $$CASE IF (1 CC) (*2C N + $$CASE BARRIER NON-PRE-N);

#!! !Numerals

#!! * __IkNumN__ ik is num before N Sg
REMOVE:IkNumN (Pron) IF (0 ("ик"))(1 N + Sg);
#!! * __IkNumAN__ ik is num before A N Sg
REMOVE:IkNumAN (Pron) IF (0 ("ик"))(1 A)(2 N + Sg);

#!! * __KumNumAN__ ik is num before A N Sg
REMOVE:KumNumAN N IF (0 ("кум"))(1 A OR N);

#!! !Pronouns
#!! * __NotInterr__ if Rel
REMOVE:NotInterr Interr IF (-2 N)(-1 (","))(0 Rel);

#!! * __Dem__ if noun follows
SELECT:Dem Dem IF (0 Dem)(1 N + Nom);

#!! * __уке__
SELECT:AdvUke Adv IF (0 ("уке"))(1 CLB OR EOS OR ("гын"));

#!! !Postpositions

#!! * __PoNeedsGen__ removes postposition if the word to the left is not Gen
REMOVE:PoNeedsGen Po IF (NOT -1 Gen OR Nom);


#!! !!Adverbs

SELECT:modat ("мо") IF (0 ("молан"))(*0 DAT-V OR DAT-PO OR DAT-A BARRIER CLB) ;

#!! * __molan__ awaiting rules for dative verbs subcategorising for mo Dat
REMOVE:molan ("мо") IF (0 ("молан")) ;
#SELECT:molan ("мо") IF (0 ("молан")) ;

REMOVE:AdvNotPcle Pcle IF (0 Adv)(1 V);

REMOVE:PcleKillsAdv Adv IF (0 Pcle);

#!! *__RemAdvAfterNom__ removes Adv if N Nom to the left
REMOVE:RemAdvAfterNom Adv IF (-1 N + Nom) ; #SASHA ADDED 03-07-2017

#!! !!Verbs
#     =====

#!! !Finite verb or Gerundium

#!! *__RemGer__ removes Ger Gen if there is no verb to the right 
REMOVE:Past (Ger Gen) IF (NOT 1 V) ;

#!! * __FinNotGer__ removes Ger if there is a Ind Prt2 Sg3 in the clause
REMOVE:FinNotGer Ger IF (0 Ind + Prt2 + Sg3)(NOT *0 VFIN);

#!! * __GerNotFin__  Ger if there is a Ind next
SELECT:GerNotFin Ger IF (1 Ind OR Inf) ;

#!! * __GerNotFin__  Ger if there is a Ger da Ger VFin
SELECT:GerNotFin2 Ger IF (1 CC)(2C Ger) ;

#!!* __Conneg__ ConNeg if there is Neg to the left
IFF:Conneg ConNeg IF (*-1 Neg BARRIER WORD - Pcle) ; #JEREMY AND SASHA ADDED 28-06-2017

#!!* __NegVerb__ if there is ConNeg to the right
IFF:NegVerb Neg IF (*1 ConNeg BARRIER WORD - Pcle) ; #JEREMY AND SASHA MODIFIED 28-06-2017

#!! !First or third person

#!! * __Sg1NotSg3__ removes Prt1 Sg3 when Pers Sg1 Nom in same clause
REMOVE:Sg1NotSg3 (Prt1 Sg3) IF (*-1 (Pers Sg1 Nom) BARRIER N + Nom OR Pers + Sg3 + Nom)(0 (V Prt1 Sg1));

#!! * __Sg3NotSg1__ removes Prt1 Sg1 when there is no Pers Sg1 Nom in same clause
#REMOVE:Sg3NotSg1 (Prt1 Sg1) IF (NOT *0 (Pers Sg1 Nom)) ;
#!! ** This definitely is too strong, it precludes zero Sg1 subjects

#!! !ConNeg or not
#!! * __NoConNeg1__ No ConNeg if no Neg to the left
REMOVE:NoConNeg1 ConNeg IF (NOT *-1 Neg BARRIER CLB);
#!! * __NoConNeg2__ No ConNeg if another ConNeg to the left
REMOVE:NoConNeg2 ConNeg IF (-1* ConNeg BARRIER Neg);

#!! !да

#!! * __da1__ Adv initially
SELECT:da1 Adv IF (-1 BOS)(0 ("да"))(1 EOS OR COMMA);
## Да, я знаю

#!! * __da2__ CC elsewhere
REMOVE:da2 Adv IF (0 ("да"));
## Коми да мари

#!! !и
#!! * __iNotAbbr__
REMOVE:iNotAbbr ABBR IF (0 CC)(NOT 1 ("."));

#!! !Interjection

#!! * __NoExclNoInterj__
REMOVE:NoExclNoInterj Interj IF (NOT 1* ("!") BARRIER COMMA) ;

#!! !Predicative

#!! __AifVövny__ selects A if вӧвны somewhere to the left
SELECT:AifVövny A IF (*-1 ("вӧвны") BARRIER N);


SECTION

MAP:shkepo @>P TARGET ("шке") IF (1 Po);

MAP:shkeadvl @ADVL> TARGET ("шке") IF (NOT 0 OBLCASE)(NOT 1 N);
MAP:shkeattr @>N TARGET ("шке") IF (NOT 0 OBLCASE)(1 N);

MAP:preNmodif @>N TARGET N + Gen IF (1C N);
MAP:preNmodif @>N TARGET Pron + Gen IF (1C N);
	
MAP:obj @OBJ> TARGET Acc (*1 V);
MAP:subj @SUBJ> TARGET Nom (*1 V);
MAP:vfin @+FMAINV TARGET Ind ;
